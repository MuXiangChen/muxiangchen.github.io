import{_ as o,c as s,e as l,o as t}from"./app-gihhjKhR.js";const i={};function n(d,e){return t(),s("div",null,e[0]||(e[0]=[l('<h2 id="node-js-的特点" tabindex="-1"><a class="header-anchor" href="#node-js-的特点"><span>Node.js 的特点</span></a></h2><ul><li><p>异步、非阻塞 IO 模型</p></li><li><p>事件循环</p></li><li><p>单线程</p></li><li><p>总结：轻量和高效</p></li></ul><p>Node.js 的性能和效率非常高。</p><p>传统的 Java 语言是一个请求开启一个线程，当请求处理完毕后就关闭这个线程。而 Node.js 则完全没有采用这种模型，它本质上就是一个单线程。</p><p>你可能会疑问：一个线程如何服务于大量的请求、如何处理高并发的呢？这是因为，Node.js 采用的是异步的、非阻塞的模型。</p><p>这里所谓的“单线程”，指的是 Node 的主线程只有一个。为了确保主线程不被阻塞，主线程是用于接收客户端请求。但不会处理具体的任务。而 Node 的背后还有一个线程池，线程池会处理长时间运行的任务（比如 IO 操作、网络操作）。线程池里的任务是通过队列和事件循环的机制来执行。</p><h2 id="使用-node-js-时的劣势" tabindex="-1"><a class="header-anchor" href="#使用-node-js-时的劣势"><span>使用 Node.js 时的劣势</span></a></h2><ul><li><p>程序运行不稳定，可能会出现服务不可用的情况</p></li><li><p>程序运行效率较低，每秒的请求数维持在一个较低的水平</p></li><li><p>前端同学对服务器端的技术不太熟悉。</p></li></ul>',8)]))}const p=o(i,[["render",n],["__file","02-Node.js的特点.html.vue"]]),r=JSON.parse('{"path":"/Frontend/11-Node.js/02-Node.js%E7%9A%84%E7%89%B9%E7%82%B9.html","title":"02-Node.js的特点","lang":"en-US","frontmatter":{"title":"02-Node.js的特点","publish":true},"headers":[{"level":2,"title":"Node.js 的特点","slug":"node-js-的特点","link":"#node-js-的特点","children":[]},{"level":2,"title":"使用 Node.js 时的劣势","slug":"使用-node-js-时的劣势","link":"#使用-node-js-时的劣势","children":[]}],"git":{"updatedTime":1735788687000,"contributors":[{"name":"Jasmine Mo","username":"Jasmine Mo","email":"loxluthor@gmail.com","commits":1,"url":"https://github.com/Jasmine Mo"}]},"filePathRelative":"Frontend/11-Node.js/02-Node.js的特点.md"}');export{p as comp,r as data};
