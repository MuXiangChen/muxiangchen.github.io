import{_ as n,c as s,e,o as l}from"./app-gihhjKhR.js";const i={};function t(p,a){return l(),s("div",null,a[0]||(a[0]=[e(`<blockquote><p>为什么在讲ES6之前，我们需要先了解ES5？因为很多人就是在学习ES6的过程中，才接触到es5这个概念。</p></blockquote><h2 id="es的几个重要版本" tabindex="-1"><a class="header-anchor" href="#es的几个重要版本"><span>ES的几个重要版本</span></a></h2><ul><li><p>ES 5 : 09年发布。</p></li><li><p>ES 6(ES2015) : 2015年发布，也称为ECMA2015。</p></li><li><p>ES 7(ES2016) : 2016年发布，也称为ECMA2016 (变化不大)。</p></li></ul><h2 id="严格模式的理解" tabindex="-1"><a class="header-anchor" href="#严格模式的理解"><span>严格模式的理解</span></a></h2><p>我们知道，JS的语法是非常灵活的，比如说，我们随便写一个变量<code>x</code>，这个变量其实是挂在 windows下面的。这种灵活性在有些情况下，反而是一种缺点，造成了全局污染。因此，ES5还引入了一种严格的运行模式：&quot;严格模式&quot;（strict mode）。</p><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><p>顾名思义，严格模式使得 Javascript 在更严格的语法条件下运行。限制性更强，也更安全。</p><p><strong>目的</strong>：</p><ul><li><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</p></li><li><p>消除代码运行的一些不安全之处，为代码的安全运行保驾护航。</p></li><li><p>为未来新版本的Javascript做好铺垫</p></li></ul><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><ul><li><p>针对整个文件：将<code>use strict</code>放在文件的第一行，则整个文件将以严格模式运行。</p></li><li><p>针对单个函数：将<code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行。</p></li></ul><p>PS：如果浏览器不支持，则这句话只会被解析为一条简单的语句，没有任何副作用。</p><p>脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。</p><h3 id="语法和行为改变" tabindex="-1"><a class="header-anchor" href="#语法和行为改变"><span>语法和行为改变</span></a></h3><ul><li><p>必须用var声明变量</p></li><li><p>禁止自定义的函数中的this指向window</p></li><li><p>创建eval作用域</p></li><li><p>对象不能有重名的属性</p></li></ul><h2 id="严格模式和普通模式的区别" tabindex="-1"><a class="header-anchor" href="#严格模式和普通模式的区别"><span>严格模式和普通模式的区别</span></a></h2><blockquote><p>下面列举几条严格模式的内容。</p></blockquote><h3 id="全局变量显式声明" tabindex="-1"><a class="header-anchor" href="#全局变量显式声明"><span>全局变量显式声明</span></a></h3><p>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p><h3 id="禁止this关键字指向全局对象" tabindex="-1"><a class="header-anchor" href="#禁止this关键字指向全局对象"><span>禁止this关键字指向全局对象：</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">        <span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上方代码中，普通模式打印的是window。严格模式下打印的是undefined。</p><h3 id="创设eval作用域" tabindex="-1"><a class="header-anchor" href="#创设eval作用域"><span>创设eval作用域</span></a></h3><h3 id="禁止使用with语句" tabindex="-1"><a class="header-anchor" href="#禁止使用with语句"><span>禁止使用with语句</span></a></h3><p>因为with语句无法在编译时就确定，属性到底归属哪个对象。</p><h3 id="构造函数必须通过new实例化对象" tabindex="-1"><a class="header-anchor" href="#构造函数必须通过new实例化对象"><span>构造函数必须通过new实例化对象</span></a></h3><p>构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。</p><p>比如说：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">        var Cat = function (name) {</span>
<span class="line">            this.name = name;</span>
<span class="line">        }</span>
<span class="line"></span>
<span class="line">        Cat(&#39;haha&#39;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上方代码中，如果在严格模式下，则会报错。</p><h3 id="为了让代码更安全-禁止函数内部遍历调用栈" tabindex="-1"><a class="header-anchor" href="#为了让代码更安全-禁止函数内部遍历调用栈"><span>为了让代码更安全，禁止函数内部遍历调用栈</span></a></h3><h3 id="严格模式下无法删除变量" tabindex="-1"><a class="header-anchor" href="#严格模式下无法删除变量"><span>严格模式下无法删除变量</span></a></h3><h3 id="属性相关" tabindex="-1"><a class="header-anchor" href="#属性相关"><span>属性相关</span></a></h3><p>普通模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。</p><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p><p>普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</p><p>普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。</p><p>比如下面这样的代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">	<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">		<span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">&#39;smyh&#39;</span><span class="token punctuation">;</span></span>
<span class="line">		<span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">&#39;vae&#39;</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码，在严格模式下属于语法错误，因为有重名的属性。</p><h3 id="函数必须声明在顶层" tabindex="-1"><a class="header-anchor" href="#函数必须声明在顶层"><span>函数必须声明在顶层</span></a></h3><p>将来Javascript的新版本会引入&quot;块级作用域&quot;。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。</p><h3 id="新增关键字" tabindex="-1"><a class="header-anchor" href="#新增关键字"><span>新增关键字</span></a></h3><p>为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>至少要能答出四五条。</p><p>参考链接：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener noreferrer">阮一峰 | Javascript 严格模式详解</a></li></ul><h2 id="我的公众号" tabindex="-1"><a class="header-anchor" href="#我的公众号"><span>我的公众号</span></a></h2><p>想学习<strong>更多技能</strong>？不妨关注我的微信公众号：<strong>千古壹号</strong>。</p><p>扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：</p><p><img src="https://img.smyhvae.com/20200102.png" alt=""></p>`,52)]))}const c=n(i,[["render",t],["__file","02-ES5中的严格模式.html.vue"]]),d=JSON.parse('{"path":"/Frontend/05-JavaScript%E5%9F%BA%E7%A1%80%EF%BC%9AES6%E8%AF%AD%E6%B3%95/02-ES5%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html","title":"02-ES5中的严格模式","lang":"en-US","frontmatter":{"title":"02-ES5中的严格模式"},"headers":[{"level":2,"title":"ES的几个重要版本","slug":"es的几个重要版本","link":"#es的几个重要版本","children":[]},{"level":2,"title":"严格模式的理解","slug":"严格模式的理解","link":"#严格模式的理解","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":3,"title":"语法和行为改变","slug":"语法和行为改变","link":"#语法和行为改变","children":[]}]},{"level":2,"title":"严格模式和普通模式的区别","slug":"严格模式和普通模式的区别","link":"#严格模式和普通模式的区别","children":[{"level":3,"title":"全局变量显式声明","slug":"全局变量显式声明","link":"#全局变量显式声明","children":[]},{"level":3,"title":"禁止this关键字指向全局对象：","slug":"禁止this关键字指向全局对象","link":"#禁止this关键字指向全局对象","children":[]},{"level":3,"title":"创设eval作用域","slug":"创设eval作用域","link":"#创设eval作用域","children":[]},{"level":3,"title":"禁止使用with语句","slug":"禁止使用with语句","link":"#禁止使用with语句","children":[]},{"level":3,"title":"构造函数必须通过new实例化对象","slug":"构造函数必须通过new实例化对象","link":"#构造函数必须通过new实例化对象","children":[]},{"level":3,"title":"为了让代码更安全，禁止函数内部遍历调用栈","slug":"为了让代码更安全-禁止函数内部遍历调用栈","link":"#为了让代码更安全-禁止函数内部遍历调用栈","children":[]},{"level":3,"title":"严格模式下无法删除变量","slug":"严格模式下无法删除变量","link":"#严格模式下无法删除变量","children":[]},{"level":3,"title":"属性相关","slug":"属性相关","link":"#属性相关","children":[]},{"level":3,"title":"函数必须声明在顶层","slug":"函数必须声明在顶层","link":"#函数必须声明在顶层","children":[]},{"level":3,"title":"新增关键字","slug":"新增关键字","link":"#新增关键字","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"我的公众号","slug":"我的公众号","link":"#我的公众号","children":[]}],"git":{"updatedTime":1735788687000,"contributors":[{"name":"Jasmine Mo","username":"Jasmine Mo","email":"loxluthor@gmail.com","commits":1,"url":"https://github.com/Jasmine Mo"}]},"filePathRelative":"Frontend/05-JavaScript基础：ES6语法/02-ES5中的严格模式.md"}');export{c as comp,d as data};
